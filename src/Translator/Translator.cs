using System.Collections.Generic;
using System.Text;

namespace jfc {
    /// <summary> Class responsible for translating the source code to LLVM IR </summary>
    public partial class Translator {
        private int _globalCount = 0;
        private int _localCount = 0;
        private int _procedureCount = 0;
        private int _basicBlockCount = 0;
        private readonly StringBuilder _globals = new();
        private readonly StringBuilder _mainHeader = new();
        private readonly StringBuilder _mainBody = new();
        private readonly StringBuilder _finishedProcedures = new();
        private readonly Stack<StringBuilder> _procedures = new();

        /// <summary> The temorary variable counter </summary>
        public int TempCount { get; set; } = 1;

        /// <summary> Instantiates the class </summary>
        public Translator() {
            // Set up a bunch of shit
            _globals.AppendLine("; The following LLVM Assembly was automatically generated by jfc");
            _globals.AppendLine("target triple = \"x86_64-pc-linux-gnu\"\n");
            _globals.AppendLine("; Global Variable Declarations");
            _mainHeader.AppendLine("; Main Enty-Point Function");
            _mainHeader.AppendLine("define i32 @main() {");
        }

        /// <summary> Finishes building the output </summary>
        /// <returns> The finished assembly translation </returns>
        public string Finish() {
            // Smash everything together
            StringBuilder sb = new();
            sb.AppendLine(_globals.ToString());
            sb.Append(_mainHeader);
            _mainBody.AppendLine("\t; Return successfully");
            _mainBody.AppendLine("\tret i32 0");
            _mainBody.AppendLine("}\n");
            sb.Append(_mainBody);
            sb.Append(_finishedProcedures);
            sb.Append(_lib);
            return sb.ToString();
        }

        /// <summary> Declares a new variable </summary>
        /// <param name="variable"> The variable to be declared </param>
        /// <param name="isGlobal"> Whether or not the variable is in the global scope </param>
        public void DeclareVariable(Symbol variable, bool isGlobal) {
            if (isGlobal) {
                variable.AssemblyName = GetNextGlobal() + variable.Name;
                _globals.AppendLine($"{variable.AssemblyName} = private global {GetDefaultValue(variable)}");
            } else {
                variable.AssemblyName = GetNextLocal() + variable.Name;
                StringBuilder sb = _procedures.Peek();
                string dt = GetDataType(variable);
                sb.AppendLine($"\t{variable.AssemblyName} = alloca {dt}");
                sb.AppendLine($"\tstore {GetDefaultValue(variable)}, {dt}* {variable.AssemblyName}\n");
            }
        }

        /// <summary> Starts the translation of a procedure </summary>
        /// <param name="procedure"> The procedure to be translated </param>
        public void StartProcedure(Symbol procedure) {
            // First we'll create a string builder for the procedure
            StringBuilder sb = new();
            _procedures.Push(sb);

            // Set the procedure name
            procedure.AssemblyName = GetNextProcedure() + procedure.Name;

            // Now we'll start to build up the first line
            sb.Append("define ");
            sb.Append(GetDataType(procedure));
            sb.Append(" " + procedure.AssemblyName + "(");

            // Now add the arguments if there are any
            if (procedure.Parameters.Length > 0) {
                sb.Append(GetDataType(procedure.Parameters[0]));
                sb.Append(" %arg0");
                for (int idx = 1; idx < procedure.Parameters.Length; idx++) {
                    sb.Append($", {GetDataType(procedure.Parameters[idx])} %arg{idx}");
                }
            }

            // Now finish the header
            sb.AppendLine(") {");

            // Now we need to convert our arguments to memory locations
            for (int idx = 0; idx < procedure.Parameters.Length; idx++) {
                Symbol arg = procedure.Parameters[idx];
                arg.AssemblyName = $"%a{idx}-{arg.Name}";
                string dt = GetDataType(arg);
                sb.AppendLine($"\t{arg.AssemblyName} = alloca {dt}");
                sb.AppendLine($"\tstore {dt} %arg{idx}, {dt}* {arg.AssemblyName}\n");
            }
        }

        /// <summary> Finishes building the current procedure </summary>
        /// <param name="procedure"> The procedure to be translated </param>
        public void FinishProcedure(Symbol procedure) {
            StringBuilder sb = _procedures.Pop();
            sb.AppendLine($"\t; Return successfully\n\tret {GetDefaultValue(procedure)}");
            sb.AppendLine("}");
            _finishedProcedures.AppendLine(sb.ToString());
        }

        /// <summary> Writes a comment </summary>
        public void Comment(string msg) {
            StringBuilder sb = GetBuilder();
            sb.AppendLine(msg);
        }

        /// <summary> Casts an integer to a floating-point value </summary>
        public string IntToFloat(string reg, int arraySize) {
            StringBuilder sb = GetBuilder();
            string res = GetNextTemp();
            string dti = GetDataType(DataType.INTEGER, arraySize);
            string dtf = GetDataType(DataType.FLOAT, arraySize);
            sb.AppendLine($"\t{res} = sitofp {dti} {reg} to {dtf} ; Cast int to float");
            return res;
        }

        /// <summary> Casts a floating-point to an integer </summary>
        public string FloatToInt(string reg, int size) {
            StringBuilder sb = GetBuilder();
            string res = GetNextTemp();
            string dtf = GetDataType(DataType.FLOAT, size);
            string dti = GetDataType(DataType.INTEGER, size);
            sb.AppendLine($"\t{res} = fptosi {dtf} {reg} to {dti} ; Cast float to int");
            return res;
        }

        /// <summary> Casts a boolean to an integer </summary>
        public string BoolToInt(string reg, int size) {
            StringBuilder sb = GetBuilder();
            string res = GetNextTemp();
            string dtb = GetDataType(DataType.BOOL, size);
            string dti = GetDataType(DataType.INTEGER, size);
            sb.AppendLine($"\t{res} = zext {dtb} {reg} to {dti} ; Cast bool to int");
            return res;
        }

        /// <summary> Casts an integer to a boolean </summary>
        public string IntToBool(string reg, int size) {
            StringBuilder sb = GetBuilder();
            string res = GetNextTemp();
            if (size == 0) {
                sb.AppendLine($"\t{res} = icmp ne i32 {reg}, 0 ; Cast bool to int");
            } else {
                string dt = GetDataType(DataType.INTEGER, size);
                sb.Append($"\t{res} = icmp ne {dt} {reg}, < i32 0");
                size--;
                while (size > 0) { sb.Append(", i32 0"); size--; }
                sb.AppendLine(" > ; Cast bool to int");
            }
            return res;
        }

        /// <summary> Translates a variable reference to assembly </summary>
        public string VariableReference(Symbol variable) {
            StringBuilder sb = GetBuilder();
            string dt = GetDataType(variable);
            string result = GetNextTemp();
            sb.AppendLine($"\t{result} = load {dt}, {dt}* {variable.AssemblyName} ; Reference to \"{variable.Name}\"");
            return result;
        }

        /// <summary> Translates an array index to assembly </summary>
        public string VectorIndex(string vec, string idx, DataType dataType, int vectorSize) {
            StringBuilder sb = GetBuilder();
            string dt = GetDataType(dataType, vectorSize);
            string res = GetNextTemp();
            sb.AppendLine($"\t{res} = extractelement {dt} {vec}, i32 {idx} ; Array index");
            return res;
        }

        /// <summary> Translates a procedure reference to assembly </summary>
        public string ProcedureReference(Symbol procedure, Queue<string> args) {
            // Start at the beginning
            StringBuilder sb = GetBuilder();
            string dt = GetDataType(procedure);
            string res = GetNextTemp();
            sb.Append($"\t{res} = call {dt} {procedure.AssemblyName}(");

            // Add any arguments
            if (args.Count > 0) {
                sb.Append($"{GetDataType(procedure.Parameters[0])} {args.Dequeue()}");
                for (int idx = 1; idx < procedure.Parameters.Length; idx++) {
                    string adt = GetDataType(procedure.Parameters[idx]);
                    sb.Append($", {adt} {args.Dequeue()}");
                }
            }

            // Finish the call
            sb.AppendLine($") ; Call to \"{procedure.Name}\"");
            return res;
        }

        /// <summary> Updates the value for a variable </summary>
        public void Assignment(Symbol target, string reg, string idx) {
            StringBuilder sb = GetBuilder();
            string dt = GetDataType(target);
            string src = target.AssemblyName;
            if (idx == null) {
                sb.AppendLine($"\tstore {dt} {reg}, {dt}* {src} ; Update variable \"{target.Name}\"\n");
            } else {
                string vec = VariableReference(target);
                string res = GetNextTemp();
                string dti = GetDataType(target.DataType, 0);
                sb.AppendLine($"\t{res} = insertelement {dt} {vec}, {dti} {reg}, i32 {idx} ; Update at index");
                sb.AppendLine($"\tstore {dt} {res}, {dt}* {src} ; Update variable \"{target.Name}\"\n");
            }
        }

        /// <summary> Translates the header to an if statement to assembly </summary>
        public (string, string) IfHeader(string cond) {
            StringBuilder sb = GetBuilder();
            string lblThen = GetNextBasicBlock();
            string lblNext = GetNextBasicBlock();
            sb.AppendLine($"\tbr i1 {cond}, label {lblThen}, label {lblNext} ; Evaluate if statement condition\n");
            return (lblThen, lblNext);
        }

        /// <summary> Transitions from the then to the else clause </summary>
        public string IfElseTransition(string lblElse) {
            StringBuilder sb = GetBuilder();
            string lblEnd = GetNextBasicBlock();
            sb.AppendLine("\t; End then clause");
            sb.AppendLine($"\tbr label {lblEnd}\n");
            BasicBlock(lblElse);
            return lblEnd;
        }

        /// <summary> Finishes an if-else statement </summary>
        public void IfElseEnd(string lblEnd) {
            StringBuilder sb = GetBuilder();
            sb.AppendLine("\t; End else clause");
            sb.AppendLine($"\tbr label {lblEnd}\n");
            BasicBlock(lblEnd);
        }

        /// <summary> Finishes an if statemene </summary>
        public void IfEnd(string lblEnd) {
            StringBuilder sb = GetBuilder();
            sb.AppendLine("\t; End if clause");
            sb.AppendLine($"\tbr label {lblEnd}\n");
            BasicBlock(lblEnd);
        }

        /// <summary> Starts a loop </summary>
        public string ForBegin() {
            StringBuilder sb = GetBuilder();
            string lblCond = GetNextBasicBlock();
            sb.AppendLine("\t; Begin loop conditional");
            sb.AppendLine($"\tbr label {lblCond}\n");
            BasicBlock(lblCond);
            return lblCond;
        }

        /// <summary> Transition from the loop conditional to the body </summary>
        public string ForBody(string cond) {
            StringBuilder sb = GetBuilder();
            string lblBody = GetNextBasicBlock();
            string lblEnd = GetNextBasicBlock();
            sb.AppendLine($"\tbr i1 {cond}, label {lblBody}, label {lblEnd} ; Evaluate loop conditional\n");
            BasicBlock(lblBody);
            return lblEnd;
        }

        /// <summary> End for-loop </summary>
        public void ForEnd(string lblCond, string lblEnd) {
            StringBuilder sb = GetBuilder();
            sb.AppendLine("\t; Go back to the loop conditional");
            sb.AppendLine($"\tbr label {lblCond}\n");
            BasicBlock(lblEnd);
        }

        /// <summary> Creates a new basic block </summary>
        public void BasicBlock(string lbl) {
            StringBuilder sb = GetBuilder();
            sb.AppendLine($"\t; Begin new basic block");
            sb.AppendLine($"\t{lbl[1..]}:\n");
        }

        /// <summary> Gets the currently active string builder </summary>
        /// <returns> The currently active string builder </returns>
        private StringBuilder GetBuilder() {
            if (_procedures.Count != 0)
                return _procedures.Peek();
            else
                return _mainBody;
        }

        /// <summary> Gets the default value for a symbol </summary>
        /// <param name="symbol"> The symbol whose default value is to be retrieved </param>
        /// <returns> The default value for the symbol </returns>
        private static string GetDefaultValue(Symbol symbol) {
            // Get the data type and array size of the symbol
            DataType dt = symbol.DataType;
            int arraySize = 0;
            if (symbol.SymbolType == SymbolType.VARIABLE && symbol.IsArray) {
                arraySize = symbol.ArraySize;
            }

            // Get the base default value
            string baseVal = GetDataType(dt, 0) + " " + dt switch {
                DataType.BOOL => "true",
                DataType.INTEGER => "0",
                DataType.FLOAT => "0.0",
                DataType.STRING => "TODO: STRING DEFAULT",
                _ => throw new System.Exception("How the fuck did you even get here?")
            };

            // If we don't have an array, then we're good to go
            if (arraySize == 0) return baseVal;

            // Otherwise we'll build the array
            StringBuilder sb = new();
            sb.Append(GetDataType(symbol) + " < ");
            sb.Append(baseVal);
            arraySize--;
            while (arraySize > 0) {
                sb.Append(", " + baseVal);
                arraySize--;
            }
            sb.Append(" >");
            return sb.ToString();
        }

        /// <summary> Gets a new temporary register </summary>
        /// <returns> The name of the new register </returns>
        private string GetNextTemp() {
            string register = $"%{TempCount}";
            TempCount++;
            return register;
        }

        /// <summary> Gets a prefix for the name of a new global variable </summary>
        /// <returns> The prefix for the name of a new global variable</returns>
        private string GetNextGlobal() {
            string prefix = $"@g{_globalCount}-";
            _globalCount++;
            return prefix;
        }

        /// <summary> Gets a prefix for the name of a new local variable </summary>
        /// <returns> The prefix for the name of a new local variable </returns>
        private string GetNextLocal() {
            string prefix = $"%l{_localCount}-";
            _localCount++;
            return prefix;
        }

        /// <summary> Gets a prefix for the name of a new procedure </summary>
        /// <returns> The prefix for the name of a new procedure </returns>
        private string GetNextProcedure() {
            string prefix = $"@p{_procedureCount}-";
            _procedureCount++;
            return prefix;
        }

        /// <summary> Gets a the name of a new basic block </summary>
        /// <returns> The name of a new basic block </returns>
        private string GetNextBasicBlock() {
            string prefix = $"%lbl{_basicBlockCount}";
            _basicBlockCount++;
            return prefix;
        }

        /// <summary> Converts a data type to LLVM assymbly </summary>
        /// <param name="symbol"> The symbol who's type is to be converted </param>
        /// <returns> The data type in LLVM assembly </returns>
        private static string GetDataType(Symbol symbol) {
            int arraySize = 0;
            if (symbol.SymbolType == SymbolType.VARIABLE && symbol.IsArray) {
                arraySize = symbol.ArraySize;
            }
            return GetDataType(symbol.DataType, arraySize);
        }

        /// <summary> Converts a data type to LLVM assembly </summary>
        /// <param name="dataType"> The data type </param>
        /// <param name="arraySize"> The array size </param>
        /// <returns> The data type in LLVM assembly </returns>
        private static string GetDataType(DataType dataType, int arraySize) {
            // First convert the data type
            string dt = dataType switch {
                DataType.BOOL => "i1",
                DataType.INTEGER => "i32",
                DataType.FLOAT => "float",
                DataType.STRING => "[128 x i8]",
                _ => throw new System.Exception("How the fuck did you get here?")
            };

            // If we don't have an array, then we're good to go
            if (arraySize == 0) return dt;

            // Otherwise build the array identifier
            return $"<{arraySize} x {dt}>";
        }

        private string VectorScalarOp(string vec, string reg, string op, DataType dataType, int arraySize, string msg) {
            StringBuilder sb = GetBuilder();
            string dt = GetDataType(dataType, 0);
            string dtv = GetDataType(dataType, arraySize);
            string res = vec;
            for (int idx = 0; idx < arraySize; idx++) {
                string tmp0 = GetNextTemp();
                sb.AppendLine($"\t{tmp0} = extractelement {dtv} {res}, i32 {idx}");
                string tmp1 = GetNextTemp();
                sb.AppendLine($"\t{tmp1} = {op} {dt} {tmp0}, {reg}");
                string tmp2 = GetNextTemp();
                sb.Append($"\t{tmp2} = insertelement {dtv} {res}, {dt} {tmp1}, i32 {idx}");
                if (idx != arraySize - 1) sb.Append('\n');
                res = tmp2;
            }
            sb.AppendLine(" ; " + msg);
            return res;
        }

        private string ScalarVectorOp(string vec, string reg, string op, DataType dataType, int arraySize, string msg) {
            StringBuilder sb = GetBuilder();
            string dt = GetDataType(dataType, 0);
            string dtv = GetDataType(dataType, arraySize);
            string res = vec;
            for (int idx = 0; idx < arraySize; idx++) {
                string tmp0 = GetNextTemp();
                sb.AppendLine($"\t{tmp0} = extractelement {dtv} {res}, i32 {idx}");
                string tmp1 = GetNextTemp();
                sb.AppendLine($"\t{tmp1} = {op} {dt} {reg}, {tmp0}");
                string tmp2 = GetNextTemp();
                sb.Append($"\t{tmp2} = insertelement {dtv} {res}, {dt} {tmp1}, i32 {idx}");
                if (idx != arraySize - 1) sb.Append('\n');
                res = tmp2;
            }
            sb.AppendLine(" ; " + msg);
            return res;
        }
    }
}
